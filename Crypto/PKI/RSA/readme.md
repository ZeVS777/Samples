# Загрузка и использвание RSA ключей в .NET

Существуют несколько методов загрузка RSA ключей и создание соответствующих криптографических объектов в .NET. 
Такие алгоритмы, как RS256, RS384, RS512, PS256, PS384, PS512 позволяют провести подпись сообщения, 
где RS генерирует всегда одну и ту же подпись для заданного приватного ключа, т.е. она является детерминированной, 
а PS имеет вероятностную природу, поэтому подписи всегда выходят разные для одного сообщения и при использовании одного 
и того же ключа. Другие же алгоритмы, такие как RSA1_5, RSA-OAEP, RSA-OAEP-256 позволяют шифровать данные публичным ключём и расшифровывать приватным. 

## Загрузка RSA из файлов приватного и публичного ключа (PEM)

Создание приватного ключа:

```bash
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:3072 -out private-key.pem
```

*rsa_keygen_bits - длина ключа (рекомендуемая длина не менее 2048)*

Создание публичного ключа:

```bash
openssl pkey -in private-key.pem -pubout -out public-key.pem
```

## Загрузка RSA из X.509 (pem, pfx)

Создание самоподписанного сертификата:

```bash
openssl req -new -x509 -key private-key.pem -out cert.pem -days 360
```

Создание PKCS#12 формата файла для хранения приватного ключа и сертификата

```bash
openssl pkcs12 -export -out cert.pfx -inkey private-key.pem -in cert.pem
```

## Загрузка RSA из JWK

Показан пример, как можно сгенерировать JWK и как из него получить RSA.

## Загрузка из эфемерного сертификата

Создание самоподписанного сертификата на лету и формирование приватного и публичного ключей.

## Использование CryptoProviderFactory для создания подписи и её проверки

**Microsoft.IdentityModel.Tokens** предлагает удобный инструмент для проведения алгоритмами RSA процедуры подтверждения валидности подписи и шифрования ключа (Key Wraping). 
Однако он поддерживает ограниченный [набор алгоритмов](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms), среди которых нет RSA-OAEP-256. Для поддержки алгоритмов, не поддерживаемых стандартными инструментами, можно расширить механизм: см. CustomCryptoProvider.cs.
